//  main.cpp（改用拟牛顿法 BFGS 优化）
#include <iostream>
#include <fstream>
#include <vector>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include "optimizer.hpp"
#include "gjf_generator.hpp"
#include "gaussian_parser.hpp"

// clamp 替代
template <typename T>
T clamp(T val, T low, T high) {
    return std::max(low, std::min(val, high));
}

bool has_collision(const std::vector<Atom>& atoms, double min_dist = 0.5) {
    for (size_t i = 0; i < atoms.size(); ++i) {
        for (size_t j = i + 1; j < atoms.size(); ++j) {
            double dx = atoms[i].x - atoms[j].x;
            double dy = atoms[i].y - atoms[j].y;
            double dz = atoms[i].z - atoms[j].z;
            double dist = std::sqrt(dx * dx + dy * dy + dz * dz);
            if (dist < min_dist) {
                std::cerr << " Collision detected: atoms " << i + 1 << " and " << j + 1
                          << " are too close (distance = " << dist << " Å)\n";
                return true;
            }
        }
    }
    return false;
}

void writeXYZ(const std::string& filename, const std::vector<Atom>& atoms) {
    std::ofstream out(filename);
    out << atoms.size() << "\nGenerated by optimizer\n";
    for (const auto& atom : atoms) {
        out << atom.symbol << " " << atom.x << " " << atom.y << " " << atom.z << "\n";
    }
    out.close();
}

int main() {
    std::vector<Atom> atoms = {
        {"C", 0.0, 0.0,  0.0},
        {"H", 0.0, 0.0, 1.07},
        {"H", 1.00880579, 0.0, -0.35666635},
        {"H", -0.50440311, -0.87365131, -0.35666635},
        {"H", -0.50440269, 0.87365131,  -0.35666635},
    };

    int iteration = 0;
    double alpha = 0.1;
    const double conv_threshold = 1e-6;
    const int max_iter = 100;
    const double max_disp = 0.5;

    std::vector<Gradient> finalGrads;
    std::vector<std::vector<double>> hessian;  //  BFGS 拟牛顿矩阵

    while (iteration < max_iter) {
        std::cout << "Iteration " << iteration << " (alpha = " << alpha << ")" << std::endl;

        std::string gjf_filename = "opt_step" + std::to_string(iteration) + ".gjf";
        bool use_scf_qc = iteration > 0;
        writeGJF(gjf_filename, atoms, iteration, use_scf_qc);

        std::string command = "g16 " + gjf_filename;
        int ret = std::system(command.c_str());
        if (ret != 0) {
            std::cerr << " Gaussian calculation failed to execute at iteration " << iteration << std::endl;
            break;
        }

        std::string log_filename = "opt_step" + std::to_string(iteration) + ".log";
        std::ifstream logfile(log_filename);
        std::string line;
        bool has_error = false;
        while (std::getline(logfile, line)) {
            if (line.find("Convergence failure") != std::string::npos ||
                line.find("Error termination") != std::string::npos) {
                has_error = true;
                break;
            }
        }
        logfile.close();

        if (has_error) {
            std::cerr << " Gaussian error detected in output file. Halting at iteration " << iteration << "\n";
            break;
        }

        std::vector<Gradient> grads = parse_gradient(log_filename);
        if (grads.empty()) {
            std::cerr << " No gradients parsed from Gaussian output.\n";
            break;
        }
        if (grads.size() != atoms.size()) {
            std::cerr << " Gradient size mismatch.\n";
            break;
        }

        finalGrads = grads;
        if (converged(grads, conv_threshold)) {
            std::cout << " Convergence reached at iteration " << iteration << std::endl;
            break;
        }

        std::vector<Atom> old_atoms = atoms;
        std::vector<Gradient> old_grads = grads;

        //  使用拟牛顿（BFGS）更新坐标
        bfgs_update(atoms, grads, old_grads, hessian, alpha);

        // 限位（防发散）
        for (size_t i = 0; i < atoms.size(); ++i) {
            double dx = atoms[i].x - old_atoms[i].x;
            double dy = atoms[i].y - old_atoms[i].y;
            double dz = atoms[i].z - old_atoms[i].z;
            atoms[i].x = old_atoms[i].x + clamp(dx, -max_disp, max_disp);
            atoms[i].y = old_atoms[i].y + clamp(dy, -max_disp, max_disp);
            atoms[i].z = old_atoms[i].z + clamp(dz, -max_disp, max_disp);
        }

        if (has_collision(atoms)) {
            std::cerr << " Collision detected after BFGS step. Aborting iteration.\n";
            break;
        }

        writeXYZ("opt_iter_" + std::to_string(iteration) + ".xyz", atoms);
        iteration++;
    }

    std::cout << "\n Optimized structure:\n";
    for (const auto& atom : atoms) {
        std::cout << atom.symbol << "    " << atom.x << "    " << atom.y << "    " << atom.z << "\n";
    }

    std::cout << "\n Final forces (Hartrees/Bohr):\n";
    for (size_t i = 0; i < finalGrads.size(); ++i) {
        std::cout << "Atom " << (i + 1) << ": "
                  << finalGrads[i].fx << "  "
                  << finalGrads[i].fy << "  "
                  << finalGrads[i].fz << "\n";
    }

    return 0;
}
